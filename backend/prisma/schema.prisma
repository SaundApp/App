generator client {
  provider = "prisma-client-js"
}

generator class_validator {
  provider = "prisma-class-validator-generator"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

model User {
  id                   String                @id @default(auto()) @map("_id") @db.ObjectId
  username             String                @unique
  bio                  String?
  name                 String
  email                String                @unique
  avatarId             String?               @db.ObjectId
  password             String?
  private              Boolean               @default(false)
  streams              Int?
  nationality          String?
  genres               String[]
  spotifyId            String?
  stripeId             String?
  verified             Boolean               @default(false)
  subscriptionSettings SubscriptionSettings?

  listeners  Listener[] @relation("artist")
  listenerOf Listener[] @relation("listener")

  followers        Follows[]      @relation("following")
  following        Follows[]      @relation("follower")
  posts            Post[]
  comments         Comment[]
  messagesSent     Message[]      @relation("sender")
  messagesReceived Message[]      @relation("receiver")
  subscriptions    Subscription[] @relation("subscriber")
  subscribers      Subscription[] @relation("subscribedTo")
  attachments      Attachment[]
  spotifyToken     SpotifyToken?
}

type SubscriptionSettings {
  perks String[] @default([])
  price Float
}

model SpotifyToken {
  id           String   @id @default(auto()) @map("_id") @db.ObjectId
  accessToken  String
  refreshToken String
  expiration   DateTime

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String @unique @db.ObjectId
}

model Subscription {
  id String @id @default(auto()) @map("_id") @db.ObjectId

  user   User   @relation("subscriber", fields: [userId], references: [id], onDelete: Cascade)
  userId String @db.ObjectId

  subscribedTo   User   @relation("subscribedTo", fields: [subscribedToId], references: [id], onDelete: Cascade)
  subscribedToId String @db.ObjectId
}

model Listener {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  count     Int
  updatedAt DateTime @default(now())
  artist    User     @relation("artist", fields: [artistId], references: [id], onDelete: Cascade)
  artistId  String   @db.ObjectId

  listener   User   @relation("listener", fields: [listenerId], references: [id], onDelete: Cascade)
  listenerId String @db.ObjectId

  @@unique([artistId, listenerId])
}

model Follows {
  id          String @id @default(auto()) @map("_id") @db.ObjectId
  follower    User   @relation("follower", fields: [followerId], references: [id], onDelete: Cascade)
  followerId  String @db.ObjectId
  following   User   @relation("following", fields: [followingId], references: [id], onDelete: Cascade)
  followingId String @db.ObjectId
}

model Post {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  name      String
  createdAt DateTime @default(now())
  image     String
  likes     String[] @default([])
  seen      String[] @default([])
  genres    String[]
  userId    String   @db.ObjectId
  url       String
  type      PostType
  spotifyId String   @unique

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  comments Comment[]

  @@unique([name, userId])
}

model Comment {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  text      String
  createdAt DateTime @default(now())
  likes     String[]
  userId    String   @db.ObjectId
  postId    String   @db.ObjectId

  user       User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  post       Post    @relation(fields: [postId], references: [id], onDelete: Cascade)
  playlistId String? @db.ObjectId
}

model Message {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  text      String
  read      Boolean  @default(false)
  createdAt DateTime @default(now())

  sender     User    @relation("sender", fields: [senderId], references: [id], onDelete: Cascade)
  senderId   String  @db.ObjectId
  receiver   User    @relation("receiver", fields: [receiverId], references: [id], onDelete: Cascade)
  receiverId String  @db.ObjectId
  replyId    String? @db.ObjectId
}

model Attachment {
  id        String         @id @default(auto()) @map("_id") @db.ObjectId
  data      Bytes
  name      String
  userId    String         @db.ObjectId
  createdAt DateTime       @default(now())
  type      AttachmentType

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

enum PostType {
  ALBUM
  SONG
  PLAYLIST
}

enum AttachmentType {
  IMAGE
  AUDIO
  VIDEO
}
